# Pods

Pods are standalone programs that can expose namespaces with functions to
babashka. Pods can be created independently from babashka. Any program can be
invoked as a pod, as long as it implements a protocol, the so called _pod
protocol_. The pod protocol is influenced by and built upon battle tested
technologies: the [nREPL](https://nrepl.org/) and
[LSP](https://microsoft.github.io/language-server-protocol/) protocols,
[bencode](https://en.wikipedia.org/wiki/Bencode),
[JSON](https://www.json.org/json-en.html),
[EDN](https://github.com/edn-format/edn) and composition of UNIX command line
tools in via good old stdin and stdout.

Pods are a brand new way to extend babashka and you should consider the protocol
alpha for now. Breaking changes may occur as we discover better ways of doing
things. Pods were introduced in babashka version `0.0.92`.

Pods you can try today:

- [pod-babashka-hsqldb](https://github.com/borkdude/pod-babashka-hsqldb): a pod
  that allows you to create and fire queries at a
  [HSQLDB](http://www.hsqldb.org/) database.

## Implementing your own pod

### Examples

Eductional examples of pods can be found [here](examples/pods):

- [pod-babashka-hsqldb](examples/pods/pod-babashka-hsqldb): a pod that allows
  you to create and fire queries at a [HSQLDB](http://www.hsqldb.org/)
  database. Implemented in Clojure.

- [pod-lispyclouds-sqlite](examples/pods/pod-lispyclouds-sqlite): a pod that
  allows you to create and fire queries at a [sqlite](https://www.sqlite.org/)
  database. Implemented in Python.

- [pod-babashka-filewatcher](examples/pods/pod-babashka-filewatcher): a
  filewatcher pod. It exposes one function `pod-babashka-filewatcher/watch` and
  return a `core.async` channel to listen for change events for a file
  path. Implemented in Rust.

### Naming

When choosing a name for your pod, considering the following naming scheme:

```
pod-<user-id>-<pod-name>
```

where `<user-id>` is your Github, Gitlab, etc. handle and `<pod-name>` describes the intent of your pod.

Examples:

- [pod-lispyclouds-sqlite](examples/pods/pod-lispyclouds-sqlite): a pod to deal with [sqlite](https://www.sqlite.org/), provided by [@lispyclouds](https://github.com/lispyclouds).

Pods created by the babashka maintainers use the identifier `babashka`:

- [pod-babashka-hsqldb](https://github.com/borkdude/pod-babashka-hsqldb): a pod to deal with [HSQLDB](http://www.hsqldb.org/)

### The protocol

Exchange of messages between babashka and the pod happens in the
[bencode](https://en.wikipedia.org/wiki/Bencode) format. Bencode is a bare-bones
format that only has four types:

- integers
- lists
- dictionaries (maps)
- byte strings

When calling the `babashka.pods/load-pod` function, babashka will start the pod
and leave the pod running throughout the duration of a babashka script.

#### describe

The first message that babashka will send to the pod on its stdin is:

``` clojure
{"op" "describe"}
```

The pod should reply to this request with something like this:

``` clojure
{"format" "json"
 "namespaces"
 [{"name" "pod.lispyclouds.sqlite"
   "vars" [{"name" "execute!"}]}]}
```

In this reply, the pod declares that _payloads_ will be encoded and decoded
using JSON (the other supported payload format is EDN). It also declares that
the pod exposes one namespace, `pod.lispyclouds.sqlite` with one var `execute!`.

Upon receiving this message, babashka will create these namespaces and vars. The
vars refer to functions that, upon invocation, will communicate with the pod
using the `invoke` op. Let's call them _proxy vars_.

With the above implementation, the user can load your pod with:

``` clojure
(require '[babashka.pods :as pods])
(pods/load-pod "pod-lispyclouds-sqlite")
(some? (find-ns 'pod.lispyclouds.sqlite)) ;;=> true
(require '[pod.lispyclouds.sqlite :as sql])
```

#### invoke

When the user invokes a proxy var, `(sql/execute! "select * from foo")` babashka
will send the following message to the pod:

``` clojure
{"id" "1d17f8fe-4f70-48bf-b6a9-dc004e52d056"
 "var" "pod.lispyclouds.sqlite/execute!"
 "args" "[\"select * from foo\"]"
```

The `id` is a random value generated by babashka which correlates requests and
responses. The `args` payload is a string encoded using EDN.

An example response to this request could look like:

``` clojure
{"id" "1d17f8fe-4f70-48bf-b6a9-dc004e52d056"
 "value" "[[1] [2]]"
 "status" "[\"done\"]"
```


